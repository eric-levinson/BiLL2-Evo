'use client'

import { useChat, Chat } from '@ai-sdk/react'
import type { UIMessage } from '@ai-sdk/react'
import { DefaultChatTransport } from 'ai'
import {
  useMemo,
  useEffect,
  useCallback,
  useRef,
  createContext,
  useContext
} from 'react'
import { toast } from 'sonner'
import { useQueryState } from 'nuqs'
import { useAISDKRuntime } from '@assistant-ui/react-ai-sdk'
import { AssistantRuntimeProvider } from '@assistant-ui/react'
import {
  getSession,
  getUserSessions,
  type ChatSessionSummary
} from '@/lib/supabase/sessions'
import { supabase } from '@/lib/supabase/client'
import { usePlaygroundStore } from '@/store'
import type { SessionEntry } from '@/types/playground'
import {
  deduplicateToolCalls,
  ensureMessageIds
} from '@/lib/utils/deduplicateMessages'

/**
 * Context for sharing session-related state across components.
 * Provides sessionId, refreshSessions, messages, and clearChat.
 */
interface AssistantSessionContextValue {
  sessionId: string | null
  refreshSessions: () => Promise<void>
  messages: UIMessage[]
  clearChat: () => void
}

const AssistantSessionContext =
  createContext<AssistantSessionContextValue | null>(null)

/**
 * Hook that creates an AssistantRuntime from the existing AI SDK chat instance.
 * Preserves all session management and Supabase persistence logic.
 */
export function useAssistantRuntime() {
  const [sessionId, setSessionId] = useQueryState('session')
  const lastLoadedSessionId = useRef<string | null>(null)
  const { setSessionsData, setIsSessionsLoading } = usePlaygroundStore()

  // Generate a stable ID for new chats - this will be used if no sessionId exists
  // We generate it once and store it so the Chat instance doesn't change on every render
  const newChatIdRef = useRef<string | null>(null)
  if (!sessionId && !newChatIdRef.current) {
    newChatIdRef.current = crypto.randomUUID()
    console.log(
      '[Session] Pre-generating ID for new chat:',
      newChatIdRef.current
    )
  } else if (sessionId) {
    // Clear the pre-generated ID when we have an actual session
    newChatIdRef.current = null
  }

  // Use either the sessionId from URL or the pre-generated ID for new chats
  const chatId = sessionId || newChatIdRef.current

  // Create a Chat instance with transport that includes sessionId in body
  // This is memoized to prevent recreating on every render
  const chat = useMemo(() => {
    const transport = new DefaultChatTransport({
      api: '/api/chat'
    })

    return new Chat({
      // Always pass an ID - either from URL or pre-generated
      id: chatId!,
      transport,
      onError: (error: Error) => {
        console.error('Chat error:', error)
        toast.error('Failed to send message. Please try again.')
      }
      // NO onFinish callback here - server handles persistence via consumeStream
    })
  }, [chatId])

  const chatHelpers = useChat({ chat })

  const { messages, error, setMessages } = chatHelpers

  // NOTE: deduplicateToolCalls is applied when loading sessions from DB
  // (see loadSession below) and in server-side persistence (route.ts).
  // It was previously also wrapped here in useMemo over every streaming
  // chunk, but that caused 2-3 minute UI freezes on large responses
  // because react-markdown re-parsed megabytes of content on each chunk.

  // Track the session ID that was auto-generated to prevent trying to load it from DB
  const autoGeneratedSessionIdRef = useRef<string | null>(null)

  // Update URL with the pre-generated ID after first message is sent
  useEffect(() => {
    // If we have messages but no sessionId in URL, update URL with pre-generated ID
    if (!sessionId && messages.length > 0 && newChatIdRef.current) {
      console.log(
        '[Session] Updating URL with pre-generated ID:',
        newChatIdRef.current
      )
      autoGeneratedSessionIdRef.current = newChatIdRef.current
      setSessionId(newChatIdRef.current)
    }
  }, [sessionId, messages.length, setSessionId])

  // Reset auto-generated tracking when sessionId is cleared
  useEffect(() => {
    if (!sessionId) {
      autoGeneratedSessionIdRef.current = null
    }
  }, [sessionId])

  // Clear chat: reset messages and session
  const clearChat = useCallback(() => {
    setMessages([])
    setSessionId(null)
    lastLoadedSessionId.current = null
  }, [setMessages, setSessionId])

  // Function to refresh sessions list from Supabase
  const refreshSessions = useCallback(async () => {
    try {
      const {
        data: { user },
        error: userError
      } = await supabase.auth.getUser()

      if (userError || !user) {
        console.warn('No user found, skipping session refresh')
        return
      }

      const sessions: ChatSessionSummary[] = await getUserSessions(user.id)
      const sessionEntries: SessionEntry[] = sessions.map((session) => ({
        session_id: session.id,
        title: session.title,
        created_at: new Date(session.created_at).getTime()
      }))

      setSessionsData(sessionEntries)
    } catch (error) {
      console.error('Error refreshing sessions:', error)
    }
  }, [setSessionsData])

  // Show error toast on error
  useEffect(() => {
    if (error) {
      toast.error(error.message || 'An error occurred')
    }
  }, [error])

  // Load session messages when sessionId changes
  useEffect(() => {
    // Skip if no sessionId or if we already loaded this session
    if (!sessionId || sessionId === lastLoadedSessionId.current) {
      return
    }

    // Skip if this session was auto-generated (doesn't exist in DB yet)
    if (sessionId === autoGeneratedSessionIdRef.current) {
      console.log(
        '[Session] Skipping load for auto-generated session:',
        sessionId
      )
      return
    }

    const loadSession = async () => {
      setIsSessionsLoading(true)
      try {
        const session = await getSession(sessionId)
        if (session && session.messages) {
          // Deduplicate tool calls to prevent rendering errors, then
          // ensure every message has a non-empty ID so assistant-ui's
          // MessageRepository tree doesn't collapse duplicate "" keys.
          const cleanedMessages = ensureMessageIds(
            deduplicateToolCalls(session.messages)
          )
          // Update messages from loaded session
          setMessages(cleanedMessages)
          // Track that we loaded this session to prevent duplicate loads
          lastLoadedSessionId.current = sessionId
        } else {
          // Session doesn't exist in database - clear it and start fresh
          console.log(
            '[Session] Session not found in database, clearing:',
            sessionId
          )
          setSessionId(null)
          setMessages([])
        }
      } catch (err) {
        console.error('Error loading session:', err)
        // Don't show error toast for missing sessions - just clear them
        setSessionId(null)
        setMessages([])
      } finally {
        setIsSessionsLoading(false)
      }
    }

    loadSession()
  }, [sessionId, setMessages, setIsSessionsLoading, setSessionId])

  // Wrap the AI SDK chat with assistant-ui runtime adapter
  // Pass deduplicated messages to prevent duplicate key crashes in tapResources
  const runtime = useAISDKRuntime({ ...chatHelpers, messages })

  return {
    runtime,
    sessionId,
    refreshSessions,
    messages,
    clearChat
  }
}

/**
 * Provider that creates an AssistantRuntime from the AI SDK chat instance
 * and makes it available to all assistant-ui components.
 * Also provides session-related state via AssistantSessionContext.
 */
export function AssistantRuntimeProviderWrapper({
  children
}: {
  children: React.ReactNode
}) {
  const { runtime, sessionId, refreshSessions, messages, clearChat } =
    useAssistantRuntime()

  const sessionContextValue = useMemo(
    () => ({ sessionId, refreshSessions, messages, clearChat }),
    [sessionId, refreshSessions, messages, clearChat]
  )

  return (
    <AssistantRuntimeProvider runtime={runtime}>
      <AssistantSessionContext.Provider value={sessionContextValue}>
        {children}
      </AssistantSessionContext.Provider>
    </AssistantRuntimeProvider>
  )
}

/**
 * Hook to access session-related state from AssistantRuntimeProviderWrapper.
 * Must be used within an AssistantRuntimeProviderWrapper.
 */
export function useAssistantSession(): AssistantSessionContextValue {
  const ctx = useContext(AssistantSessionContext)
  if (!ctx) {
    throw new Error(
      'useAssistantSession must be used within an AssistantRuntimeProviderWrapper'
    )
  }
  return ctx
}

export default useAssistantRuntime
